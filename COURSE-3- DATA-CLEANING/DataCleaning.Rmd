---
title: "Data Cleaning "
author: "Kedge/Junia"
date: "04/23/2021"
output: html_document
---

# Problematic 
You have been contacted by a finance magazine and the editor has sent you a data file on 500 companies and he asks you to make the following graphs:
1- a specific point cloud by industry where we can visualize the income, the expenses and the profit.
2- a point cloud including the trends of the different industries for the expenditure and income variables.
3- a Boxplot showing growth by industry.

As usual, you have to define your working directory.
```{r}
#setwd("~/Documents/PIERRE-FABRE/DATA-CLEANING")
```

We are going to load our dataset which is already in the working directory.
We can preview the data with the head function
```{r}
fin=read.csv("Futur500.csv", head=TRUE, sep=",")
head(fin, 10)
```
We can also access the tail of the file (the last lines) with the tail function.
```{r}
tail(fin,10)
```

We can also run the summary function on my dataset to get a little statistic.
```{r}
summary(fin)
```
Another function that allows us to see an overview of the data is the str function
```{r}
str(fin)
```


# Errors with factors
As you can see, the str function (for data frame structure) tells us that our dataset is indeed a data frame, that we have 500 observations and 11 variables. A part of the variables is listed with as indication for each, the type of the data, the number of modalities, the names of the first modalities, and the associated frequencies if it is of type factor. For example for the "Name" variable, it is the type factor 500 levels. This is normal since we have 500 lines.

Let us now take the Industry variable, it is also of type factor, it has 8 modalities (8 levels). They can be viewed in the summary.
the first modality is "" which means; empty, second is "Construction" and so on. We also notice that there is a series of numbers. These numbers represent an R language coding of the modalities. For example the number 8 represents the empty mode, the number 6 represents the "Construction" mode and so on.

If not, let's now look at the rest of the variables in this file.
Let us start with the variable "Inception". It indicates the years of creation of the company. In what follows, we do not need to do arithmetic operations over the years. Same thing with the variable "ID" we don't need to do arithmetic operations. We are therefore going to transform these two variables into factor.
```{r}
fin$ID<-factor(fin$ID)
#str(fin)
```


```{r}

fin$Inception<-factor(fin$Inception)
summary(fin)
str(fin)
```

Once the transformation of the Inception variable into a factor we can notice by executing the summary function, the frequencies of each modality. Example in 2011 we have 93 companies that were created.



```{r}
a<-c("12", "13", "14", "12", "12")
a
typeof(a)
```


```{r}
b<-as.numeric(a)
b
typeof(b)
```

This is the easiest way to convert characters to numeric.
Now let's see how to convert a factor to a numeric.

```{r}
z<-factor(c("12", "13", "14", "12", "12"))
z
```


As you can see, z is a vector with 3 levels, 12, 13 and 14. Here, R recognizes these digits as categories or modalities. It can be very confusing and lead to confusion.
First reflex is to convert z to a numeric vector.
We will try to do the same as before with the vector a and b using the as.numeric function.
```{r}
y<-as.numeric(z)
y
typeof(y)

```

We get here a numeric vector with the values 1 2 3 1 1, if we look at the type of y, we get a double type as before.
We did the same operations as with a and b but we do not get our vector 12 13 14 12 12.
What happened is that we took into account the factorization of the variable rather than the factors (or modalities) themselves.
To tell the truth, it assigns the value 1 for the mode 12, the value 2 for the mode 13 and the value 3 for the mode 14.
If we look at the type of z:
```{r}
typeof(z)
```

z is indeed an integer since it attributes integer values to the modalities.
When we convert z to a number we get the vector 1 2 3 1 1.
This is one of the most common mistakes in programming.
To avoid this error, we must convert our vector into a character and then into a numeric
```{r}
x=as.numeric(as.character(z))
typeof(x)
x
```

Let's go back to our dataset. We are now going to transform the "Revenue", "Expenses" and "Growth" variables which are factors into numeric variables.
It's variables are identified by R as being factors.
For example Revenue contains the symbol "$" and ",". However R automatically converts this type of data into factor since it does not know how to recognize them in numeric.
The same goes for the Expenses variable where we can also notice "," but also the word "Dollars".
Concerning the Growth variable, it is the character "%".

```{r}
str(fin)
```

Important question, how are we going to remove these characters and turn our variables into numeric?

Before answering this question, we will take a look at the variable "Profit". It is of type int and that's perfect.
To illustrate what we have studied from the beginning, we will transform this variable into a factor and then transform it back into a numÃ©ric (int).

```{r}
fin$Profit<-factor(fin$Profit)
```

```{r}
str(fin)
```

```{r}
head(fin)
```
We notice here that the data of the variable "Profit" are the same as before its transformation into factor.

Now let's try to transform this variable into numeric:
```{r}
fin$Profit<-as.numeric(fin$Profit)
```


For the sake of display, we will use the head function for each instruction indicating or not the number of lines we want to see on the output file in HTML format.
```{r}
head(fin)
```


```{r}
str(fin)
```

As we can see, Profit is of type numeric but we no longer get the same values. 342 instead of 8553827 ...
As we saw in the previous example with the variables z and y, R codes the modalities or characteristics by assigning them codes or values.

```{r}
fin=read.csv("Futur500.csv", head=TRUE, sep=",")
fin$ID<-factor(fin$ID)
fin$Inception<-factor(fin$Inception)
str(fin)
```


# Functions sub() et gsub()
```{r}
?gsub
```

As we can read in the description of the function sub (), this function, takes as argument a pattern the element that we want to modify, the replacement is the structure that we want to put and x is the variable where we want to do this replacement.
```{r}
fin$Expenses<-gsub(" Dollars", "", fin$Expenses)
head(fin)
fin$Expenses<-gsub(",","", fin$Expenses)
head(fin)
str(fin)
```
As can now be seen, the Expenses variable is of type chr. We will come back later to complete the transformation.

We are now interested in the variable "Revenue" which is a little different than "Expenses".
```{r}
fin$Revenue<-gsub("$","",fin$Revenue)
head(fin)
```

As we can see, with this writing nothing is happening. Because \$ is a special character in R. In order for the R language to understand that we want to find the sequence \$ in the string, we have to use the symbol \.
```{r}
fin$Revenue<-gsub("\\$","",fin$Revenue)
fin$Revenue<-gsub(",","",fin$Revenue)
head(fin)
str(fin)
```

```{r}
fin$Growth<-gsub("%","",fin$Growth)
head(fin)
str(fin)
```

As we can see the 3 variables are of character type, so we can easily convert them to numeric type.

```{r}
fin$Expenses<-as.numeric(fin$Expenses)
fin$Revenue<-as.numeric(fin$Revenue)
fin$Growth<-as.numeric(fin$Growth)
head(fin)
str(fin)
```


# The missing data
You will never be faced with missing data again.
This is due to certain errors in data entry or manipulation.
To remedy this, several options are available to us:
1- Predict missing data with 100% accuracy.
For example you can fill in fields if you are on information. In our example, if we have the information on the income and the expenses, it would be simple to deduct the profit.
Or if we have the name of a city and we are missing the state (for the US) department, it is also easy to fill in the missing information.

2- Leave the cell (or information) empty.
This is in the case where the field or the variable is not important, in this case, having missing information is not important.
However, there are algorithms that allow you to manage these empty fields.

3- delete the entire line.
This is a method that is not recommended since our study ends up with a small sample.
But sometimes we only have that option.

4-Replace with the mean or the median
It is the most popular method in data science. It is better to replace with the median than the mean since the median is not affected by extreme values.

5- Complete using predictive models.
We can explore the correlation or the regression between two variables, define the line and thus the missing values.

## NA values
I suggest you to read about NA by typing the command
```{r}
?NA
```
As you can read, this is a logical variable.
Let's take an example :
Consider the following proposition:
Jean has a car.
This proposition is either true or false and if we do not know it in R, it is NA.

```{r}
TRUE #1
FALSE #0
NA
```

```{r}
TRUE ==FALSE
```

```{r}
TRUE==5
```

```{r}
TRUE==1
```

```{r}
FALSE==4
```

```{r}
FALSE==FALSE
```

```{r}
FALSE==0
```

```{r}
NA==TRUE
```

```{r}
NA==FALSE
```

```{r}
NA==15
```

```{r}
15==NA
```

```{r}
NA==NA
```
NA tells us that we are comparing a missing value to something, but we do not know the value of the missing value. That's why we get NA every time.
```{r}
head(fin,24)
```

```{r}
head(complete.cases(fin),24) 
```
The complete.cases (end) function will cycle through the file and return a vector with TRUE and FALSE.
  TRUE indicates that the row has no missing data. FALSE indicates the row with missing data.
```{r}
head(fin[complete.cases(fin),],24)

```

This instruction returns a data frame with only the rows or there is no missing data.
If we rather want a data frame with only the missing data:
```{r}
!complete.cases(fin)
fin[!complete.cases(fin),]
```

We can compare this result with the excel file and see that there are more than 6 lines with missing data, just complete.cases will look for the lines with NA and does not count the lines where the fields are empty.

To remedy this problem we have to go back to the beginning with our read.csv function.

```{r}
fin=read.csv("Futur500.csv", head=TRUE, sep=",", na.strings = c(""))


fin$ID<-factor(fin$ID)
fin$Inception<-factor(fin$Inception)
fin$Expenses<-gsub(" Dollars", "", fin$Expenses)
fin$Expenses<-gsub(",","", fin$Expenses)
fin$Revenue<-gsub("\\$","",fin$Revenue)
fin$Revenue<-gsub(",","",fin$Revenue)
fin$Growth<-gsub("%","",fin$Growth)
fin$Expenses<-as.numeric(fin$Expenses)
fin$Revenue<-as.numeric(fin$Revenue)
fin$Growth<-as.numeric(fin$Growth)
str(fin)
```
```{r}
fin[!complete.cases(fin),]
```
na.strings = c ("") we have indicated with this instruction to replace empty fields with NA.
As we can see, empty fields are replaced by NA.
We may encounter the <NA> notation. What is the difference with NA?
The answer is simple, when it comes to factor that is to say, a variable with modalities, we use <NA> otherwise if it is numeric we will find the notation NA.

# Filter Functions
## Filter with which()

Let's say I want to select the rows that contain an income of 9746272.
```{r}
fin$Revenue==9746272		
```

We get a vector with values True if there is matching and False otherwise.
We also have the value NA, this implies that our language has compared the value 9746272 to the value NA and as we had specified above, this returns us NA.


If we want to filter only the lines that match the value of 9746272	: 
```{r}
fin[fin$Revenue==9746272, ]
```
As we can see, we get 3 lines. Two lines are at NA, this implies that when R matches the value 9746272 with a value NA it gives NA, this is not FALSE nor TRUE but NA.
```{r}
9746272	==NA
```
With which we can get the exact row with the requested value. Which no longer counts NA values.
```{r}
which(fin$Revenue==9746272)
```
If I want to view the line whose revenue = 9746272:
```{r}
fin[which(fin$Revenue==9746272), ]
# petit rappel, si on souhaite les lignes 3,4,5 d'un data frame l'instruction est la suivante 
#fin[c(3,4,5),]

```
Consider another example with the Employees variable.
We will look for lines or companies with a workforce of 45 employees.

```{r}
fin[fin$Employees==45,]
```

If you want the lines without the NA:
```{r}
fin[which(fin$Employees==45),]
```


## Filter with is.na()

```{r}
head(fin,24)
```
Let's imagine that we want to retrieve the rows whose Expenses variable is at NA.
First reflex is to write as follows:
```{r}
fin$Expenses==NA
```
Or in data frame version
```{r}
head(fin[fin$Expenses==NA,],10)
```

As we said, we cannot compare with NA.

We will introduce the is.na () function.
```{r}
a<-c(1,24,456,NA, 76,33,NA)
is.na(a)
```

is.na() indicates by TRUE when the matching with NA takes place.

```{r}
is.na(fin$Expenses)

```


```{r}
fin[is.na(fin$Expenses),]
```

## Delete missing data:
In what follows, we want to delete the two lines corresponding to the two missing fields of the Industry variable.
```{r}
fin_backup<-fin
fin[!complete.cases(fin),] # qui indique toutes les lignes avec au moins une valeur NA.

```

```{r}
fin[is.na(fin$Industry),]
```

This instruction tells us that it is lines 14 and 15 that have NA fields at the level of the Induystry variable.

Now if you want to delete these two lines from the data frame, nothing could be easier:
```{r}
head(fin[!is.na(fin$Industry),],24) #opposÃ©

```

```{r}
fin<-fin[!is.na(fin$Industry),]
```

```{r}
head(fin,24)
```

We can notice that lines 14 and 15 have indeed been deleted.

## Resetting the data frame index:
As we can see, we have deleted both lines but the line numbers remain unchanged.
To change line numbers
```{r}
rownames(fin)<-1:nrow(fin)
head(fin,25)
tail(fin, 25)
```
Another way to do it is

```{r}
fin<-fin_backup
fin<-fin[!is.na(fin$Industry),]
rownames(fin)<-NULL
head(fin,25)
tail(fin, 25)
```

## Replace missing values
In this part we will replace the missing values.
For example we want to fill in the missing fields of the variable "State"

```{r}
fin[!complete.cases(fin),]
```

```{r}
fin[is.na(fin$State),]
```

```{r}
fin[is.na(fin$State) & fin$City=="New York",]
```

```{r}
fin[is.na(fin$State) & fin$City=="New York","State"]<-"NY"

```

```{r}
fin[c(11,377),]
```

We can do the same with san francisco

```{r}
fin[is.na(fin$State),]
fin[is.na(fin$State) & fin$City=="San Francisco",]
fin[is.na(fin$State) & fin$City=="San Francisco","State"]<-"CA"
fin[c(82,265),]
```

```{r}
fin[!complete.cases(fin),]
```

We can notice that the number of lines in with NA values decreases more and more.

## Replace NA with Mediane
In this part, we will focus on the Employees variable and we will filter according to the type of industry, here the Greenfax company is of the Retail type (we can do this to find the missing value according to the City variable or the variable Inception. Only according to the type of industry seems the most representative. Nevertheless, as we can notice it, we cannot approximate the missing value by the mean since it does not make any sense since we have extreme values (1 and 7125) The median seems the most plausible aternative since it is not affected by these values.
```{r}
median(fin[, "Employees"])
```

```{r}
median(fin[, "Employees"],na.rm=TRUE)
```

```{r}
median(fin[fin$Industry=="Retail", "Employees"],na.rm=TRUE)

med_empl_retail <-median(fin[fin$Industry=="Retail", "Employees"],na.rm=TRUE)
```

Nous allons maintenant attribuer cette valeur Ã  la variable Employees de la ligne 3.

```{r}
fin[is.na(fin$Employees) &  fin$Industry=="Retail", "Employees"]<-med_empl_retail
fin[3,]
```

We will do the same for the type of industry "Financial services"

```{r}
median(fin[fin$Industry=="Financial Services", "Employees"],na.rm=TRUE)
med_empl_financial <-median(fin[fin$Industry=="Financial Services", "Employees"],na.rm=TRUE)
```


```{r}
fin[is.na(fin$Employees)&fin$Industry=="Financial Services", "Employees"]<-med_empl_financial
fin[330,]
```

```{r}
fin[!complete.cases(fin),]
```
 
We will continue to replace the NA values in the "Growth" variable.
```{r}
med_growth_constru<-median(fin[fin$Industry == "Construction","Growth"], na.rm=TRUE)
med_growth_constru
fin[is.na(fin$Growth)&fin$Industry=="Construction", "Growth"]<- med_growth_constru
fin[8,]
```
 We are going to do the same for the "Revenue" and "Expenses" variables.
 
```{r}
med_rev_constru<-median(fin[fin$Industry == "Construction","Revenue"], na.rm=TRUE)
med_rev_constru
fin[is.na(fin$Revenue)&fin$Industry=="Construction", "Revenue"]<- med_rev_constru
fin[8,]

```

```{r}
med_exp_constru<-median(fin[fin$Industry == "Construction","Expenses"], na.rm=TRUE)
med_exp_constru
fin[is.na(fin$Expenses)&fin$Industry=="Construction", "Expenses"]<- med_exp_constru
fin[8,]

```
# Important note:
As you can see in Expenses, we shouldn't infer values without checking. Indeed, the IT Services line does have NA in Expenses but we can deduce it other than by using the median.
To deduce these monquant values, we must use the following formulas:
Revenue- Expenses = Profit
Expenses = Revenue - Profit


```{r}
fin[!complete.cases(fin),]
```


```{r}
fin[is.na(fin$Profit), "Profit"] <- fin[is.na(fin$Profit), "Revenue"] - fin[is.na(fin$Profit), "Expenses"]
```


```{r}
fin[c(8,42),]
```

```{r}
fin[!complete.cases(fin),]
```

```{r}
fin[is.na(fin$Expenses), "Expenses"] <- fin[is.na(fin$Expenses), "Revenue"] - fin[is.na(fin$Expenses), "Profit"]
```

```{r}
fin[15,]
```

```{r}
fin[!complete.cases(fin),]
```

# Visualization


2- a point cloud including the trends of the different industries for the expenditure and income variables.
3- a Boxplot showing growth by industry.
```{r}
library(ggplot2)
```

To start, we will visualize the point cloud representing the Revenue, Expenses and Profit variables.
1- a specific point cloud by industry where we can visualize the income, the expenses and the profit.
```{r}
p<-ggplot(data=fin)+ aes(x= Revenue, y= Expenses, size= Profit,colour= Industry)+ geom_point()
p
```

2- a point cloud including the trends of the different industries for the expenditure and income variables.
```{r}
p<-ggplot(data=fin)+ aes(x= Revenue, y= Expenses,colour= Industry)+ geom_point()
p
p+geom_smooth(fill= NA, size = 1)
```

geom_smooth allows you to draw trend curves.
a Boxplot showing growth by industry.
## Boxplot
```{r}
f<-ggplot(data=fin)+ aes(x= Industry, y= Growth, colour = Industry)+ geom_boxplot(size=1)
f
```


```{r}
f+geom_jitter()+geom_boxplot(size=1, alpha=0.5, outlier.colour = NA)
```


